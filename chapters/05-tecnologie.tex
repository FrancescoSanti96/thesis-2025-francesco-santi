\chapter{Tecnologie}

\section{Stack tecnologico landing pages}
Il progetto di redesign delle landing pages si basa su uno stack moderno orientato a performance, SEO e developer experience. Le scelte tecnologiche sono state guidate dalla necessità di garantire caricamenti rapidi, indicizzazione ottimale e scalabilità futura.

\subsection{Frontend}

\textbf{Next.js 15 con React 19 e TypeScript 5.7}

Il framework principale è Next.js 15.3, che si basa su React 19 e TypeScript 5.7:

\begin{itemize}
  \item \textbf{React 19}: Libreria JavaScript per costruire interfacce utente component-based. Permette di creare UI dichiarative, riutilizzabili e facilmente manutenibili attraverso il paradigma a componenti
  
  \item \textbf{TypeScript 5.7}: Superset di JavaScript che aggiunge type safety statico. Riduce drasticamente bug in produzione grazie al type checking in fase di sviluppo e migliora la developer experience con autocompletion e refactoring sicuro
  
  \item \textbf{Next.js 15}: Framework React che estende le funzionalità base con routing, rendering ottimizzato e tooling integrato
\end{itemize}

\textbf{Perché Next.js per landing pages}

La scelta di Next.js rispetto a React vanilla si basa su vantaggi concreti per il progetto:

\begin{itemize}
  \item \textbf{Rendering ibrido}: Next.js 15 permette di combinare SSR on-demand per pagine dinamiche (form, autenticazione) con cache intelligente per contenuti statici. Implementata strategia di revalidation time-based (1 ora per dati esterni) e manual revalidation con \texttt{revalidatePath()} per contenuti che cambiano (blog, admin actions)
  
  \item \textbf{SEO nativo}: Meta tags dinamici, sitemap XML automatico, structured data JSON-LD integrati out-of-the-box. SSR garantisce che crawler Google ricevano HTML completo immediatamente, fondamentale per indicizzazione e traffico organico
  
  \item \textbf{App Router multilingua}: Gestione nativa routing /it/ e /en/ con supporto i18n attraverso next-intl, permettendo espansione internazionale senza refactoring architetturale
  
  \item \textbf{Code splitting automatico}: Ogni route genera bundle JavaScript separati, riducendo significativamente il payload iniziale rispetto a SPA tradizionale. Il browser carica solo il codice necessario per la pagina corrente
  
  \item \textbf{Image optimization}: Componente next/image con conversione WebP automatica, lazy loading nativo, srcset responsive e placeholder blur integrati. Ottimizzazione significativa del peso immagini mantenendo qualità visiva
\end{itemize}

\subsection{Styling e UI}

\textbf{Tailwind CSS 3.4 + ShadCN UI}

Sistema di styling utility-first con component library accessibile:

\begin{itemize}
  \item \textbf{Tailwind CSS}: Framework CSS con classi utility per costruire UI direttamente nel markup. Zero runtime overhead (tutto compilato in CSS statico), configurazione custom per palette Datapizza, purge automatico rimuove CSS non utilizzato (riduzione 95\% bundle finale)
  
  \item \textbf{ShadCN UI (Radix UI)}: Component library basata su oltre 20 componenti Radix UI (@radix-ui/react-*) per accessibilità WCAG 2.1 integrata. Approccio copy-paste (codice nel progetto, non npm dependency) permette customizzazione completa mantenendo primitive accessibili
\end{itemize}

\subsection{Librerie complementari}

\textbf{Animazioni e interattività}
\begin{itemize}
  \item Framer Motion 12.9 per animazioni fluide Hero sections e scroll effects
  \item Three.js 0.177 + React Three Fiber per visualizzazioni 3D su landing AI Engineering
\end{itemize}

\textbf{Form e validazione}
\begin{itemize}
  \item React Hook Form 7.54 per gestione form performante senza re-render
  \item Zod 3.24 per schema validation TypeScript-first su lead generation form
\end{itemize}

\subsection{Backend per dati dinamici}

Alcune funzionalità landing richiedono backend Django:
\begin{itemize}
  \item API REST per submit form lead generation (validazione server-side)
  \item Integrazione newsletter "Commit" via Customer.io
  \item Dati real-time opportunità Jobs da PostgreSQL 15
  \item Tracking eventi Mixpanel server-side (fallback GDPR-compliant)
\end{itemize}

\textbf{Stack}: Django 4.x + PostgreSQL 15 (Python 3.9, Poetry, aiohttp per performance asincrone, boto3 per AWS integration)

\section{Stack tecnologico aziendale}
L'ecosistema Datapizza (Jobs, Company, gestionale) condivide stack unificato per coerenza tecnologica.

\textbf{Frontend}: React 19 + TypeScript 5.7 su tutti i prodotti. React Query (TanStack Query) per state management server con caching intelligente e optimistic updates. TanStack Router in progressiva adozione per routing type-safe end-to-end.

\textbf{Backend}: Django 4.x + PostgreSQL 15 come stack verticale Python (team expertise consolidata, ecosystem ricco per AI/ML). Python 3.9 con Poetry per dependency management, aiohttp per web server asincrono.

\textbf{Infrastructure}: AWS per cloud infrastructure. Landing pages deployate come container Docker con immagini gestite tramite AWS ECR (Elastic Container Registry, region eu-south-1). S3 storage per asset statici, CloudFront CDN per distribuzione globale. Lambda serverless per integrazioni AI con scalabilità automatica. Gestione ambienti staging e production tramite configurazioni Docker separate (dettagli processo deploy in Cap. 8).

\textbf{Analytics e Communication}: Mixpanel per event tracking GDPR compliant con funnel analysis. Customer.io per email automation newsletter "Commit" (500k+ iscritti) e transactional emails.

\section{Development tools e workflow}

\textbf{IDE e AI assistance}: VS Code come IDE principale con Cursor AI (abbonamento premium team). Approccio AI-first per coding assistance, refactoring e debugging, con review rigorosa umana per qualità codice.

\textbf{Version Control}: GitLab self-hosted (migrazione da GitHub durante periodo) per repository privato con maggiore sicurezza e ottimizzazione costi. Git workflow con feature branches e Merge Request con code review obbligatoria.

\textbf{Project Management}: Jira per task tracking, sprint planning e gestione backlog. Workflow Agile con sprint bisettimanali, story points estimation e burndown charts per monitoring avanzamento.

\textbf{CI/CD e Deploy}: GitLab CI per pipeline automatizzate build/test e deploy 
automatico su AWS tramite Docker container. Preview deployments per ogni 
Merge Request tramite ambienti staging dedicati.

\textbf{Communication}: Discord e Google Meet per daily standup e sincronizzazione team. Google Workspace per produttività e condivisione documenti.

\textbf{Documentation}: Notion per knowledge base aziendale (documentazione rilasci, onboarding, architecture decisions, runbook incident management).