\chapter{Dispiegamento in opera}

\section{Architettura deployment}

L'applicazione Next.js è stata deployata su infrastruttura AWS seguendo
un'architettura cloud-native basata su containerizzazione Docker.

\subsection{Stack deployment}

\begin{itemize}
  \item \textbf{Next.js rendering ibrido}: Combinazione di Static
Generation (SSG) per blog posts tramite \texttt{generateStaticParams}, con
Incremental Static Regeneration (ISR) per contenuti dinamici (revalidation
1 ora per opportunità lavorative)

    \item \textbf{Containerizzazione Docker}: Multi-stage build per
    ottimizzazione dimensione immagini

  \item \textbf{AWS Cloud Infrastructure}: AWS ECR (Elastic Container
Registry, region eu-south-1) per gestione immagini Docker, S3 storage per
immagini remote, repository ECR separati per staging e production
\end{itemize}

\section{Workflow deployment}

Il deployment è gestito attraverso script bash (\texttt{deploy-stag.sh},
\texttt{deploy-prod.sh}) che automatizzano il processo di rilascio.

\subsection{Processo deployment}

Il workflow prevede:
\begin{enumerate}
  \item Autenticazione su AWS ECR tramite AWS CLI
  \item Validazione automatica codice (TypeScript type checking con
\texttt{pnpm ts-check} e linting ESLint con \texttt{pnpm lint})
  \item Build immagine Docker con \texttt{APPENV} specifico
(staging/production)
  \item Tag immagine con nomenclatura ECR repository
  \item Push su AWS ECR regione eu-south-1
\end{enumerate}

\subsection{Gestione ambienti}

Tre ambienti separati con configurazioni dedicate:
\begin{itemize}
  \item \textbf{Development}: File \texttt{.env.dev}, ambiente locale sviluppo
  \item \textbf{Staging}: File \texttt{.env.stag}, repository ECR dedicato
  \item \textbf{Production}: File \texttt{.env.prod}, repository ECR dedicato
\end{itemize}

La configurazione ambiente viene caricata dinamicamente in
\texttt{next.config.mjs} tramite merge di \texttt{.env.base} con file
specifico ambiente.

La configurazione ambiente viene caricata dinamicamente in
\texttt{next.config.mjs} tramite merge di \texttt{.env.base} con file
specifico ambiente.

\section{Ottimizzazioni rendering}

Le pagine blog utilizzano \texttt{generateStaticParams} per pre-rendering
statico con generazione automatica route da file MDX, metadata OpenGraph
dinamici per SEO e revalidation on-demand tramite API
\texttt{/api/blog/revalidate}. I contenuti dinamici (opportunità lavorative)
utilizzano ISR con \texttt{revalidate: 3600} (1 ora) per fetch dati da CMS
esterno e fallback handling per gestione errori API.

\section{Analytics e tracking}

Sistema tracking multi-provider implementato nelle landing pages:
\begin{itemize}
  \item \textbf{Google Analytics 4}: Integrato tramite
\texttt{@next/third-parties/google}
  \item \textbf{Google Tag Manager}: Eventi custom tramite
\texttt{sendGTMEvent}
  \item \textbf{Facebook Pixel}: Tracking conversioni con event
deduplication
  \item \textbf{Segment Analytics}: Client-side tracking per user journey
  \item \textbf{Server-side tracking}: API interna per tracking analytics
lato server
\end{itemize}

Implementazione cookie consent GDPR-compliant con gestione categorie
analytics/marketing.

\section{Gestione contenuti}

Area admin custom-built per gestione blog, già presente nella codebase
e ottimizzata durante il progetto: autenticazione NextAuth.js con magic link
email, editor MDX integrato (\texttt{@mdxeditor/editor}), storage posts su
filesystem con volume Docker persistente, database SQLite (Prisma ORM) per
metadati e utenti admin, revalidation automatica path dopo modifiche
contenuti.

\section{Internazionalizzazione}

Sistema i18n con \texttt{next-intl}: supporto locales italiano (it) e
inglese (en), generazione route statiche per ogni locale, traduzioni
centralizzate in \texttt{translations/locale.json}, locale matching
automatico da headers browser.

\section{Risultati deployment}

L'architettura deployment ha garantito deploy consistenti cross-ambiente
grazie Docker multi-stage, separazione chiara ambienti staging/production
su ECR, validazione automatica pre-deploy (TypeScript + ESLint), gestione
efficiente asset statici con S3, tracking analytics completo multi-provider
e flexibility gestione contenuti con CMS integrato.

\bigskip
L'infrastruttura fornisce foundation scalabile per ecosistema landing
pages, con focus su developer experience (pnpm, TypeScript strict) e
performance rendering (SSG + ISR).