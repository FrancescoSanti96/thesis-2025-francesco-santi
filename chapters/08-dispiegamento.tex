\chapter{Dispiegamento in opera}

\section{Architettura deployment}
Il deploy delle landing pages Next.js avviene tramite containerizzazione Docker con gestione immagini su AWS ECR.

\subsection{Stack deployment}
\begin{itemize}
  \item \textbf{Next.js 15 rendering ibrido}: Combinazione SSR on-demand per pagine dinamiche e cache intelligente per contenuti statici. Strategia revalidation time-based (1 ora per dati esterni) e manual revalidation con \texttt{revalidatePath()} per contenuti che cambiano
  \item \textbf{Docker}: Containerizzazione multi-stage per immagini ottimizzate
  \item \textbf{AWS ECR}: Elastic Container Registry (region eu-south-1) per gestione immagini Docker
  \item \textbf{CloudFront CDN}: Distribuzione globale asset statici da S3
\end{itemize}

\subsection{Ambienti}
\textbf{Staging}
\begin{itemize}
  \item Ambiente pre-produzione per testing QA e UAT
  \item Configurazione: \texttt{APP\_ENV=staging} con file \texttt{.env.stag}
  \item Database staging separato da production
  \item Mixpanel project dedicato per evitare inquinamento dati production
\end{itemize}

\textbf{Production}
\begin{itemize}
  \item Ambiente live accessibile agli utenti finali
  \item URL: \texttt{datapizza.tech} (multilingua /it/ e /en/)
  \item Configurazione: \texttt{APP\_ENV=production} con file \texttt{.env.prod}
  \item Performance monitoring attivo con Mixpanel Analytics
  \item Backup automatizzati database
\end{itemize}

\section{Pipeline deployment}

\subsection{Processo build e deploy staging}
Il deployment su staging segue un processo automatizzato tramite script \texttt{deploy-stag.sh}:

\textbf{Step 1: Build Next.js}
\begin{itemize}
  \item Esecuzione \texttt{pnpm build} per generare build produzione Next.js
  \item Output ottimizzato con code splitting e tree shaking
  \item Caricamento variabili ambiente da \texttt{.env.stag}
\end{itemize}

\textbf{Step 2: Docker Build Multi-Stage}
Il Dockerfile multi-stage ottimizza dimensione finale immagine:
\begin{enumerate}
  \item \textbf{Stage dependencies}: Installazione solo production dependencies
  \item \textbf{Stage builder}: Build Next.js con \texttt{pnpm build}
  \item \textbf{Stage runner}: Immagine finale minimale con solo runtime necessario
\end{enumerate}

Benefici multi-stage:
\begin{itemize}
  \item Riduzione significativa dimensione immagine (solo runtime, no dev dependencies)
  \item Layer caching per build incrementali veloci
  \item Security hardening (minimal attack surface)
\end{itemize}

\textbf{Step 3: Tag e Push AWS ECR}
\begin{itemize}
  \item Tag immagine Docker con versione e ambiente (es. \texttt{landing:staging-v1.2.3})
  \item Autenticazione AWS CLI con credenziali IAM
  \item Push immagine su AWS ECR registry (region eu-south-1)
  \item Gestione versioni immagini per possibilità di rollback
\end{itemize}

\textbf{Step 4: Deploy}
\begin{itemize}
  \item Deploy nuova immagine Docker dall'ECR registry
  \item Container esposto su porta 80 con \texttt{next start}
  \item Verifica funzionamento post-deploy
\end{itemize}

Durata media pipeline: 5-7 minuti (build 3min, Docker build 2min, push/deploy 2min).

\subsection{Deployment production}
Processo analogo a staging ma con validazioni aggiuntive:
\begin{itemize}
  \item Prerequisito: Deploy staging testato e approvato
  \item Script \texttt{deploy-prod.sh} con variabili \texttt{.env.prod}
  \item Manual approval richiesto prima di push ECR production
  \item Rolling update ECS con zero-downtime deployment
  \item Monitoring intensificato post-deploy (primi 30 minuti)
\end{itemize}

\section{Infrastruttura AWS}

\subsection{Componenti principali}
\textbf{AWS ECR (Elastic Container Registry)}
\begin{itemize}
  \item Registry privato per immagini Docker landing pages
  \item Region: eu-south-1 (Milano) per latency ridotta
  \item Vulnerability scanning abilitato per sicurezza immagini
  \item Gestione versioni per rollback rapido
\end{itemize}

\textbf{AWS S3 + CloudFront CDN}
\begin{itemize}
  \item S3 bucket per asset statici (immagini, font, media)
  \item CloudFront distribution per edge caching globale
  \item Cache invalidation post-deploy nuovi asset
  \item Configurazione TTL per ottimizzazione cache
\end{itemize}

\section{Variabili ambiente e configurazione}

\subsection{Gestione secrets}
\begin{itemize}
  \item \textbf{AWS Secrets Manager}: Storage sicuro per API keys (Mixpanel, Customer.io, database credentials)
  \item \textbf{Environment variables}: File \texttt{.env.stag} e \texttt{.env.prod} non committati su Git
  \item \textbf{Docker build args}: Variabili build-time passate durante Docker build
  \item \textbf{ECS task definition}: Variabili runtime iniettate da Secrets Manager
\end{itemize}

Nessuna variabile sensibile in chiaro nel codice (verificato con git-secrets e pre-commit hooks).

\subsection{Configurazioni per ambiente}
\textbf{Staging (\texttt{.env.stag})}
\begin{itemize}
  \item Database: Connection string PostgreSQL staging
  \item API Backend: URL Django staging
  \item Mixpanel: Project ID staging (dati separati da production)
  \item Feature flags: Abilitazione features in beta testing
\end{itemize}

\textbf{Production (\texttt{.env.prod})}
\begin{itemize}
  \item Database: Connection string PostgreSQL production (read replica per query heavy)
  \item API Backend: URL Django production con load balancer
  \item Mixpanel: Project ID production
  \item Feature flags: Solo features stabili abilitate
\end{itemize}

\section{Strategia deployment e rollback}

\subsection{Deployment progressivo}
\begin{itemize}
  \item \textbf{Cache strategy Next.js}: Combinazione revalidation time-based (1 ora per dati esterni) e manual revalidation con \texttt{revalidatePath()} per contenuti dinamici (blog, admin actions)
  \item \textbf{Rollout per landing}: Deploy landing page per landing page, non tutte insieme
  \item \textbf{Feature flags}: Abilitazione graduale nuove funzionalità senza redeploy
\end{itemize}

Esempio rollout: Home → Recruiting → Community → AI Adoption → AI Engineering → Jobs (1 landing ogni 2-3 giorni).

\subsection{Rollback strategy}
In caso di problemi critici post-deploy:

\begin{itemize}
  \item \textbf{Docker image rollback}: Redeploy immagine precedente da ECR registry
  \item \textbf{Git rollback}: Git revert commit problematico + rebuild/redeploy
  \item \textbf{Cache invalidation}: Uso di \texttt{revalidatePath()} per invalidare cache problematiche
  \item \textbf{Database migrations}: Rollback gestito separatamente con Django migrations reverse
\end{itemize}

Tempo medio rollback: Variabile in base alla strategia (da pochi minuti per cache invalidation a 5-10 minuti per rebuild completo).

\section{Monitoring e observability}

\subsection{Logging e metriche}
\begin{itemize}
  \item Aggregazione log applicazione per debugging
  \item Monitoring performance container Docker
  \item Custom metrics: Mixpanel eventi, conversion funnel
  \item Alerting su anomalie e threshold critici
\end{itemize}

\subsection{Analytics post-deploy}
\begin{itemize}
  \item Mixpanel live view per monitorare eventi post-deploy
  \item Verifica funnel conversione funzionanti correttamente
  \item Monitoring traffico per landing page
  \item Alert su anomalie metriche significative
\end{itemize}

\section{Sicurezza deployment}

\subsection{Security best practices}
\begin{itemize}
  \item \textbf{Container security}: Immagini Docker scannate per vulnerabilità tramite AWS ECR scanning
  \item \textbf{Least privilege}: IAM roles con permessi minimi necessari per accesso AWS resources
  \item \textbf{Secrets management}: AWS Secrets Manager per storage sicuro credenziali sensibili
  \item \textbf{HTTPS enforcement}: Configurazione SSL/TLS per traffico encrypted
  \item \textbf{Security headers}: CSP, HSTS, X-Frame-Options configurati su Next.js middleware
\end{itemize}

\subsection{Compliance GDPR}
\begin{itemize}
  \item Cookie consent verificato funzionante post-deploy
  \item Mixpanel IP anonymization attiva
  \item Data retention policy configurata
  \item Gestione privacy utenti conforme normativa
\end{itemize}

\section{Backup e disaster recovery}

\subsection{Backup strategy}
\begin{itemize}
  \item \textbf{Database}: Backup regolari database con retention configurata
  \item \textbf{Container images}: ECR mantiene versioni immagini Docker per rollback
  \item \textbf{Git repository}: Backup automatico codice sorgente su GitLab self-hosted
  \item \textbf{Asset S3}: Versioning abilitato per rollback file modificati
\end{itemize}

\subsection{Disaster recovery}
\begin{itemize}
  \item Procedura DR documentata per ripristino servizio
  \item Backup database utilizzabile per restore in caso di failure
  \item Rollback rapido a versioni precedenti container tramite ECR
  \item Testing periodico procedure recovery per validare efficacia
\end{itemize}